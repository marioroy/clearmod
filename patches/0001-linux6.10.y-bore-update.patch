diff -uarp a/kernel/sched/bore.c b/kernel/sched/bore.c
--- a/kernel/sched/bore.c	2024-10-07 21:35:20.464492616 -0400
+++ b/kernel/sched/bore.c	2024-10-07 22:34:52.723318814 -0400
@@ -118,6 +118,9 @@ void restart_burst_rescale_deadline(stru
 	}
 }
 
+static inline bool task_is_bore_eligible(struct task_struct *p)
+{return p->sched_class == &fair_sched_class;}
+
 static void reset_task_weights_bore(void) {
 	struct task_struct *task;
 	struct rq *rq;
@@ -125,6 +128,7 @@ static void reset_task_weights_bore(void
 
 	write_lock_irq(&tasklist_lock);
 	for_each_process(task) {
+		if (!task_is_bore_eligible(task)) continue;
 		rq = task_rq(task);
 		rq_lock_irqsave(rq, &rf);
 		reweight_task_by_prio(task, effective_prio(task));
@@ -151,9 +155,6 @@ static u32 count_child_tasks(struct task
 	return cnt;
 }
 
-static inline bool task_is_bore_eligible(struct task_struct *p)
-{return p->sched_class == &fair_sched_class;}
-
 static inline bool burst_cache_expired(struct sched_burst_cache *bc, u64 now)
 {return (s64)(bc->timestamp + sched_burst_cache_lifetime - now) < 0;}
 
@@ -192,6 +193,7 @@ static void update_child_burst_topologic
 	struct task_struct *child, *dec;
 
 	list_for_each_entry(child, &p->children, sibling) {
+		if (!task_is_bore_eligible(child)) continue;
 		dec = child;
 		while ((dcnt = count_child_tasks(dec)) == 1)
 			dec = list_first_entry(&dec->children, struct task_struct, sibling);
